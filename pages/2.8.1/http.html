{#title|Easy VK / Node.JS ВКонтакте API | HTTP клиент}
<script>
	window.pageGot = true;
</script>
<h1>HTTP</h1>
<div class="big-quote danger">
  <div class="p">
    <span class="ic">{...}</span> Для включения или отключения используйте utils.http <br/></br/>
    <pre class="js"><code>easyvk({
  utils: {
    http: true
  }
})</code></pre></br/>
    <i>Unknow method ... of undefined</i>
  </div>
</div>
<p>
	HTTP Клиент существует в Easy VK со второй версии. Он нужен для тех случаев, когда нужно- сделать что-то такое, что не позволяет официальное API ВКонтакте. Так, например, на его основе я написал Audio API (удалено с 2.6.0 версии из-за отсутствия своевременных обновлений).
</p>
<p>
	HTTP Клиент работает по принципу HTTP сессии, если Вы хотя бы частично знакомы с алгоритмом работы HTTP, то знаете, что сессия там живет, пока о Вас можно собрать хоть какую-то информацию*, например, кукисы. Когда Вы авторизуетесь в обычном браузере во Вконтакте, Вы создаете сессию, и информация об этой сессии хранится в куках браузера. Чтобы сессия "поддерживалась", браузер отправляет кукисы каждый раз, когда делает запрос, вместе с самим запросом. Таким образом, сервер ВКонтакте всегда будет знать, что сделать с этим запросом, и какой пользователь его выполнил
</p>
<p>
	HTTP Клиент работает именно по принципу браузера, он авторизует Вас как бы "через браузер"*, и возвращает Вам объект для работы в этой авторизованной сессией. Так как авторизация происходит по протоколу HTTP, многие моменты могут перестать работать со временем, ведь ВКонтакте часто меняют свои внутренние и внешние алгоритмы, а я просто слоупок.
</p>
<p>
	В общем HTTP Клиент - это мощная, крутая особенность Easy VK, но его поддержка - это требовательное дело и требует своевременного отклика на любые изменения ВКонтакте. Вы можете его использовать, а можете написать свой, на основе библиотеки <code class="h">node-fetch</code>, это не сложно. Но будьте бдительны к ошибкам.
</p>
<p>
	Использовать HTTP Клиент нужно так:
</p>
<pre class="js"><code>easyvk().then(vk => {
	vk.http.loginByForm((client) => {
		// Первый шаг - авторизация в http клиенте, всегда
		
		client.someMethod(); // Пример работы с HTTP клиентом
	})
})
</code></pre>
<h2 id="loginByForm">http.loginByForm()</h2>
<div class="big-quote danger">
	<p>
		Для корректной работы HTTP авторизации, необходимо ВСЕГДА передавать в параметры авторизации easyvk логин и пароль пользователя, так как по <code class="h">access_token</code> логин и пароль не получить из сессии, а сам логин и пароль не сохраняются в <a href="session.html" target="_blank">сессию</a> в целях безопасности данных
	</p>
</div>
<p>
	Это самый основной метод http клиента, он запускает авторизацию во ВКонтакте, в браузере (Chrome), по Вашему текущему IP адресу. Метод возвращает объект <a href="#">Promise</a>, в случае корректной авторизации, <code class="h">resolve</code> функция получит объект <code class="h">HTTPClient</code>
</p>
<div class="big-quote">
	<p>
		Данные в HTTP клиенте с версии 2.6.0 не проверяются. Только, если нужно обновить сессию. То есть компонент не узнает, правильный или неправильный пароль вы ввели, потому как не делает доп. проверок. <br><br>
    В своем софте рекомендую делать такие проверки самостоятельно
	</p>
</div>
<p>
	Аргументы метода
</p>
<ul>
	<li>
		<b>params</b> (<a href="#">object</a>) <span class="default">{}</span>
		<p>
		 	Настройки HTTP Клиента, посмотрите, что из себя представляют настройки
		</p>
		<p>
			<pre class="js"><code>{
  cookies: __dirname + "/my-cookies.json" // Путь к файлу, где будут храниться кукисы,

  // User-agent клиента, через который будут делаться запросы (можно взять браузера любого)
  userAgent: "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71....",
  username: "ИМЯ_ПОЛЬЗОВАТЕЛЯ", // Если не настроен в основной фукнции
  password: "ПАРОЛЬ_ПОЛЬЗОВАТЕЛЯ", // Если не настроен в основной фукнции
  
  /** 
    Хендлер капчи, работает также, как в основной функции
    Если не настроен, то берется хендер из основной функции
  */
  captchaHandler: () => {},
  captchaSid: 2424, // sid последней полученной капчи
  captchaKey: "wdwd", // Ключ для решения капчи
  reauth: true, // Нужно ли делать обновление сессии
  code: '2323', // Код для двухфакторной авторизации
  checkAuth: true, // Нужно ли в данный момент проверять кукисы на валидность
  checkCodeUrl: '' // URL адрес, на который будет отправлен код из СМС/звонка/сообщения в ВК
}
			</code></pre>
		</p>
	</li>
</ul>
<pre class="js"><code>easyvk({
  username: "логин_пользователя", 
  password: "пароль"
}).then(vk => {
  
  vk.http.loginByForm({
    cookies: __dirname + "/my-cookies.json"
  }).then((HTTPClient) => {
     
     console.log(<a href="httpclient.html" target="_blank">HTTPClient</a>);

  })

})</code></pre>
<h2 id="getAccessToken">Безопасная авторизация с получением access_token'а</h2>
<p>
  Easy VK поддерживает авторизацию по данным официальных клиентов ВКонтакте, вроде приложения для Android / IOS. Но после введения ограничений на Messages API, ВКонтакте всячески стараются блокировать тех, кто авторизуется по данным таких приложений.
  Сделано это для того, чтобы спама было меньше. Я разрабатываю различный софт на основе API ВКонтакте, в основном во всех проектах я использую easyvk, и не каждый софт, мною разработанный, может называться "безопасным" с точки зрения модераторов ВКонтакте, поэтому я часто сталкиваюсь с блокировкой аккаунтов. 
  Конечно, если аккаунт не используется для каких-то вредительских целей, он не будет заблокирован, но если он отправляет много запросов, то даже если это обычные запросы вроде stories.get, вероятно, аккаунт попадет в блокировку, только потому что авторизован по данным клиентов ВК неофициально.
  Easy VK пока что не научился подделывать "официальность" авторизации, но в качестве решения данной проблемы я предлагаю вам использовать авторизацию по HTTP клиенту, но с получением access_token'а. Такой метод авторизации не гарантирует, что вы будете иметь доступ ко всем методам API (включая те, что не описаны в документации), но такой метод гарантирует безопасность аккаунта на все 100%.
</p>
<p>
  <h3>Метод</h3>
</p>
<p>
  Метод заключается в том, что сначала мы делаем авторизацию по HTTP клиенту, а потом делаем OAuth авторизацию через <a href="https://oauth.vk.com/authorize" target="_blank">https://oauth.vk.com/authorize</a>, оставаясь внутри nodejs, и не открывая браузер и другой доп. софт.
</p>
<p>
  Вот код, который получает токен по логину и паролю
</p>
<pre class="js"><code>const path = require('path')

const USERNAME = ''
const PASSWORD = ''

/* &gt;&gt; async function context &lt;&lt; */
let vk = await easyvk({
  onlyInstance: true,
  utils: {
    http: true
  }
})

let client = await vk.http.loginByForm({
  username: USERNAME,
  password: PASSWORD,
  cookies: path.join(process.cwd(), 'cookies.json'),
  reauth: true
})

response = await client.fullRequest('https://oauth.vk.com/authorize', {
  client_id: 6121396, // ID приложения
  scope: 215985366, // Полный доступ
  response_type: 'token'
})

let token = response.url.match(/access_token=([^&]+)/g)

if (!token) {
  let text = await response.text()
  let loc = text.match(/location.href = "(.*)"\+addr/g)
  loc = loc[0].replace(/location.href = "(.*)"\+addr/g, "$1")
  response = await client.fullRequest(loc, {})
}

token = response.url.match(/#access_token=([^&]+)/g)
token = token[0].replace('#access_token=', "")
console.log(token)</code></pre>
<p>
	Теперь Вам необходимо познакомиться с <a href="httpclient.html" target="_blank">клиентом</a> поближе, чтобы понять, что он может.
</p>